"use strict";(self.webpackChunkcommuto_docs=self.webpackChunkcommuto_docs||[]).push([[294],{4425:function(e,t,a){a.r(t),a.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return k},frontMatter:function(){return d},metadata:function(){return p},toc:function(){return m}});var n=a(3117),r=a(102),l=(a(7294),a(3905)),i=["components"],d={id:"core-tec-ref",title:"CommutoSwap Technical Reference"},o=void 0,p={unversionedId:"technical-reference/core-tec-ref",id:"technical-reference/core-tec-ref",title:"CommutoSwap Technical Reference",description:"This document describes the structs, events and functions used by the CommutoSwap smart contract.",source:"@site/docs/technical-reference/core-tec-ref.md",sourceDirName:"technical-reference",slug:"/technical-reference/core-tec-ref",permalink:"/docs/technical-reference/core-tec-ref",draft:!1,editUrl:"https://github.com/jimmyneutront/commuto-docs/tree/master/docs/technical-reference/core-tec-ref.md",tags:[],version:"current",frontMatter:{id:"core-tec-ref",title:"CommutoSwap Technical Reference"},sidebar:"tutorialSidebar",previous:{title:"Set Up A Development Environment",permalink:"/docs/guides/dev-env"},next:{title:"Commuto Revenue Distribution Technical Reference",permalink:"/docs/technical-reference/rev-dist-tec-ref"}},s={},m=[{value:"Offer",id:"offer",level:2},{value:"Swap",id:"swap",level:2},{value:"Dispute",id:"dispute",level:2},{value:"OfferOpened",id:"offeropened",level:2},{value:"OfferEdited",id:"offeredited",level:2},{value:"OfferCanceled",id:"offercanceled",level:2},{value:"OfferTaken",id:"offertaken",level:2},{value:"SwapFilled",id:"swapfilled",level:2},{value:"PaymentSent",id:"paymentsent",level:2},{value:"PaymentReceived",id:"paymentreceived",level:2},{value:"BuyerClosed",id:"buyerclosed",level:2},{value:"SellerClosed",id:"sellerclosed",level:2},{value:"DisputeRaised",id:"disputeraised",level:2},{value:"ResolutionProposed",id:"resolutionproposed",level:2},{value:"ReactionSubmitted",id:"reactionsubmitted",level:2},{value:"DisputedSwapClosed",id:"disputedswapclosed",level:2},{value:"DisputeEscalated",id:"disputeescalated",level:2},{value:"EscalatedSwapClosed",id:"escalatedswapclosed",level:2},{value:"ServiceFeeRateChanged",id:"servicefeeratechanged",level:2},{value:"MinimumDisputePeriodChanged",id:"minimumdisputeperiodchanged",level:2},{value:"PrimaryTimelockChanged",id:"primarytimelockchanged",level:2},{value:"DisputeResolutionTimelockChanged",id:"disputeresolutiontimelockchanged",level:2},{value:"Get Service Fee Rate",id:"get-service-fee-rate",level:2},{value:"Get Minimum Dispute Period",id:"get-minimum-dispute-period",level:2},{value:"Get Supported Settlement Methods",id:"get-supported-settlement-methods",level:2},{value:"Get Supported Stablecoins",id:"get-supported-stablecoins",level:2},{value:"Get Active Dispute Agents",id:"get-active-dispute-agents",level:2},{value:"Get Offer",id:"get-offer",level:2},{value:"Get Swap",id:"get-swap",level:2},{value:"Get Dispute",id:"get-dispute",level:2},{value:"Change Primary Timelock",id:"change-primary-timelock",level:2},{value:"Change Dispute Resolution Timelock",id:"change-dispute-resolution-timelock",level:2},{value:"Set Service Fee Rate",id:"set-service-fee-rate",level:2},{value:"Set Minimum Dispute Period",id:"set-minimum-dispute-period",level:2},{value:"Set Settlement Method Support",id:"set-settlement-method-support",level:2},{value:"Set Stablecoin Support",id:"set-stablecoin-support",level:2},{value:"Set Dispute Agent Active",id:"set-dispute-agent-active",level:2},{value:"Open Offer",id:"open-offer",level:2},{value:"Edit Offer",id:"edit-offer",level:2},{value:"Cancel Offer",id:"cancel-offer",level:2},{value:"Take Offer",id:"take-offer",level:2},{value:"Fill Swap",id:"fill-swap",level:2},{value:"Report Payment Sent",id:"report-payment-sent",level:2},{value:"Report Payment Received",id:"report-payment-received",level:2},{value:"Close Swap",id:"close-swap",level:2},{value:"Raise Dispute",id:"raise-dispute",level:2},{value:"Propose Resolution",id:"propose-resolution",level:2},{value:"React To Resolution Proposal",id:"react-to-resolution-proposal",level:2},{value:"Close Disputed Swap",id:"close-disputed-swap",level:2},{value:"Escalate Dispute",id:"escalate-dispute",level:2},{value:"Close Escalated Swap",id:"close-escalated-swap",level:2}],u={toc:m};function k(e){var t=e.components,a=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"This document describes the structs, events and functions used by the CommutoSwap smart contract."),(0,l.kt)("h1",{id:"structs"},"Structs"),(0,l.kt)("h2",{id:"offer"},"Offer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Offer {\n    bool isCreated;\n    bool isTaken;\n    address maker;\n    bytes interfaceId;\n    address stablecoin;\n    uint256 amountLowerBound;\n    uint256 amountUpperBound;\n    uint256 securityDepositAmount;\n    uint256 serviceFeeRate;\n    SwapDirection direction;\n    bytes[] settlementMethods;\n    uint256 protocolVersion;\n}\n")),(0,l.kt)("p",null,"This represents an offer within CommutoSwap."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"isCreated"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to check for offer existence")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"isTaken"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to check if offer is taken")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"maker"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The Ethereum address of the offer maker")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes"),(0,l.kt)("td",{parentName:"tr",align:"left"},"interfaceId"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The maker's Commuto interface id")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"stablecoin"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The address of the contract of the stablecoin to be swapped")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"amountLowerBound"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The minimum amount of stablecoin the maker is willing to buy/sell")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"amountUpperBound"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The maximum amount of stablecoin the maker is willing to buy/sell")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"securityDepositAmount"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount that the maker and taker must temporarily surrender as a security deposit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"serviceFeeRate"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The rate, expressed as a percentage times 100, of the taken swap amount that will be charged to both the maker and the taker as a service fee")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"direction"),(0,l.kt)("td",{parentName:"tr",align:"left"},"SwapDirection"),(0,l.kt)("td",{parentName:"tr",align:"left"},"An enum that determines whether the maker is offering to buy or sell stablecoin")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"settlementMethods"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes[]"),(0,l.kt)("td",{parentName:"tr",align:"left"},"An array of supported settlement methods, including the specification of fiat currencies and prices, by which the maker is willing to send/receive payment")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"protocolVersion"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Indicates for which version of CommutoSwap this offer was created")))),(0,l.kt)("h2",{id:"swap"},"Swap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Swap {\n    bool isCreated;\n    bool requiresFill;\n    address maker;\n    bytes makerInterfaceId;\n    address taker;\n    bytes takerInterfaceId;\n    address stablecoin;\n    uint256 amountLowerBound;\n    uint256 amountUpperBound;\n    uint256 securityDepositAmount;\n    uint256 takenSwapAmount;\n    uint256 serviceFeeAmount;\n    uint256 serviceFeeRate;\n    SwapDirection direction;\n    bytes settlementMethod;\n    uint256 protocolVersion;\n    bool isPaymentSent;\n    bool isPaymentReceived;\n    bool hasBuyerClosed;\n    bool hasSellerClosed;\n    DisputeRaiser disputeRaiser;\n}\n")),(0,l.kt)("p",null,"This represents a swap within CommutoSwap."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"isCreated"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Copied from corresponding Offer struct")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"requiresFill"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally for maker-as-seller trades to check if maker has filled swap")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"isTaken"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Copied from corresponding Offer struct")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"maker"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Copied from corresponding Offer struct")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes"),(0,l.kt)("td",{parentName:"tr",align:"left"},"makerInterfaceId"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Copied from interfaceId field of corresponding Offer struct")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"taker"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The Ethereum address of the taker")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes"),(0,l.kt)("td",{parentName:"tr",align:"left"},"takerInterfaceId"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The taker's Commuto interface id")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"stablecoin"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Copied from corresponding Offer struct")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"amountLowerBound"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Copied from corresponding Offer struct")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"amountUpperBound"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Copied from corresponding Offer struct")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"securityDepositAmount"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Copied from corresponding Offer struct")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"takenSwapAmount"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of stablecoin the taker has decided to buy/sell (note that amountLowerBound \u2264 takenSwapAmout \u2264 amountUpperBound)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"serviceFeeAmount"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount to be paid to Commuto by both the maker and taker as a service fee")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"serviceFeeRate"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Copied from corresponding Offer struct")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"direction"),(0,l.kt)("td",{parentName:"tr",align:"left"},"SwapDirection"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Copied from corresponding Offer struct")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"settlementMethod"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The settlement method by which the taker has decided to send/receive payment (note that settlementMethod must be in corresponding offer's settlementMethods field)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"protocolVersion"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Copied from corresponding Offer struct")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"isPaymentSent"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to check whether the buyer has sent fiat payment")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"isPaymentReceived"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to check whether the seller has received fiat payment")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"hasBuyerClosed"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to track whether the buyer has closed the swap and received their purchased stablecoin plus their security deposit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"hasSellerClosed"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to track whether the seller has closed the swap and received their their security deposit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"disputeRaiser"),(0,l.kt)("td",{parentName:"tr",align:"left"},"DisputeRaiser"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to track dispute status, will be set to NONE by takeOffer")))),(0,l.kt)("h2",{id:"dispute"},"Dispute"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Dispute {\n    uint disputeRaisedBlockNum;\n    address disputeAgent0;\n    address disputeAgent1;\n    address disputeAgent2;\n    bool hasDA0Proposed;\n    uint256 dA0MakerPayout;\n    uint256 dA0TakerPayout;\n    uint256 dA0ConfiscationPayout;\n    bool hasDA1Proposed;\n    uint256 dA1MakerPayout;\n    uint256 dA1TakerPayout;\n    uint256 dA1ConfiscationPayout;\n    bool hasDA2Proposed;\n    uint256 dA2MakerPayout;\n    uint256 dA2TakerPayout;\n    uint256 dA2ConfiscationPayout;\n    MatchingProposalPair matchingProposals;\n    DisputeReaction makerReaction;\n    DisputeReaction takerReaction;\n    DisputeState state;\n    bool hasMakerPaidOut;\n    bool hasTakerPaidOut;\n    uint256 totalWithoutSpentServiceFees;\n}\n")),(0,l.kt)("p",null,"This represents a dispute within CommutoSwap"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"disputeRaisedBlockNum"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The block number in which the dispute was raised")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"disputeAgent0"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The address of the first dispute agent selected by the dispute raiser")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"disputeAgent1"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The address of the second dispute agent selected by the dispute raiser")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"disputeAgent2"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The address of the third dispute agent selected by the dispute raiser")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"hasDA0Proposed"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to track whether the first selected dispute agent has submitted a resolution proposal")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"dA0MakerPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL that the first selected dispute agent recommends the maker be paid")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"dA0TakerPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL that the first selected dispute agent recommends the taker be paid")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"dA0ConfiscationPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL that the first selected dispute agent recommends be confiscated and sent to the service fee pool")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"hasDA1Proposed"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to track whether the second selected dispute agent has submitted a resolution proposal")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"dA1MakerPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL that the second selected dispute agent recommends the maker be paid")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"dA1TakerPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL that the second selected dispute agent recommends the taker be paid")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"dA1ConfiscationPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL that the second selected dispute agent recommends be confiscated and sent to the service fee pool")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"hasDA2Proposed"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to track whether the third selected dispute agent has submitted a resolution proposal")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"dA2MakerPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL that the third selected dispute agent recommends the maker be paid")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"dA2TakerPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL that the third selected dispute agent recommends the taker be paid")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"dA2ConfiscationPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL that the third selected dispute agent recommends be confiscated and sent to the service fee pool")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"matchingProposals"),(0,l.kt)("td",{parentName:"tr",align:"left"},"MatchingProposalPair"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to track which two submitted resolution proposals are identical to each other, if any")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"makerReaction"),(0,l.kt)("td",{parentName:"tr",align:"left"},"DisputeReaction"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The maker's reaction to the identical resolution proposals, if any")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"takerReaction"),(0,l.kt)("td",{parentName:"tr",align:"left"},"DisputeReaction"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The taker's reaction to the identical resolution proposals, if any")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"state"),(0,l.kt)("td",{parentName:"tr",align:"left"},"DisputeState"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to track the state of the dispute")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"hasMakerPaidOut"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to track whether the maker has closed the disputed swap and received their STBL as specified by the approved resolution proposals")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"hasTakerPaidOut"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Used internally to track whether the taker has closed the disputed swap and received their STBL as specified by the approved resolution proposals")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"totalWithoutSpentServiceFees"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The total amount of STBL that can be paid out to the maker, taker, and/or service fee pool")))),(0,l.kt)("h1",{id:"events"},"Events"),(0,l.kt)("h2",{id:"offeropened"},"OfferOpened"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"OfferOpened(bytes16 offerID, bytes interfaceId)\n")),(0,l.kt)("p",null,"Emitted when a new offer is opened"),(0,l.kt)("h2",{id:"offeredited"},"OfferEdited"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"OfferEdited(bytes16 offerID)\n")),(0,l.kt)("p",null,"Emitted when the settlement methods of an offer are changed"),(0,l.kt)("h2",{id:"offercanceled"},"OfferCanceled"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"OfferCanceled(bytes16 offerID)\n")),(0,l.kt)("p",null,"Emitted when an offer is canceled"),(0,l.kt)("h2",{id:"offertaken"},"OfferTaken"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"OfferTaken(bytes16 offerID, bytes takerInterfaceId)\n")),(0,l.kt)("p",null,"Emitted when an offer is taken"),(0,l.kt)("h2",{id:"swapfilled"},"SwapFilled"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"SwapFilled(bytes16 swapID);\n")),(0,l.kt)("p",null,"Emitted when a maker-as-seller swap is filled"),(0,l.kt)("h2",{id:"paymentsent"},"PaymentSent"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"PaymentSent(bytes16 swapID)\n")),(0,l.kt)("p",null,"Emitted when the buyer indicates that they have sent payment"),(0,l.kt)("h2",{id:"paymentreceived"},"PaymentReceived"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"PaymentReceived(bytes16 swapID)\n")),(0,l.kt)("p",null,"Emitted when the seller indicates that they have received payment"),(0,l.kt)("h2",{id:"buyerclosed"},"BuyerClosed"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"BuyerClosed(bytes16 swapID)\n")),(0,l.kt)("p",null,"Emitted when the buyer closes their side of the swap"),(0,l.kt)("h2",{id:"sellerclosed"},"SellerClosed"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"SellerClosed(bytes16 swapID)\n")),(0,l.kt)("p",null,"Emitted when the seller closes their side of the swap"),(0,l.kt)("h2",{id:"disputeraised"},"DisputeRaised"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"DisputeRaised(bytes16 swapID, address disputeAgent0, address disputeAgent1, address disputeAgent2)\n")),(0,l.kt)("p",null,"Emitted when a swapper raises a dispute"),(0,l.kt)("h2",{id:"resolutionproposed"},"ResolutionProposed"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"ResolutionProposed(bytes16 swapID, address disputeAgent)\n")),(0,l.kt)("p",null,"Emitted when a dispute agent submits a resolution proposal"),(0,l.kt)("h2",{id:"reactionsubmitted"},"ReactionSubmitted"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"ReactionSubmitted(bytes16 swapID, address addr, DisputeReaction reaction)\n")),(0,l.kt)("p",null,"Emitted when the maker or taker of a disputed swap reacts to two or more identical resolution proposals"),(0,l.kt)("h2",{id:"disputedswapclosed"},"DisputedSwapClosed"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"DisputedSwapClosed(bytes16 swapID, address closer)\n")),(0,l.kt)("p",null,"Emitted when the maker or taker of a disputed swap, for which at least two identical resolution proposals have been\nsubmitted and accepted by both the maker and taker, closes their side of the disputed swap"),(0,l.kt)("h2",{id:"disputeescalated"},"DisputeEscalated"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"DisputeEscalated(bytes16 swapID, address escalator, EscalationReason reason)\n")),(0,l.kt)("p",null,"Emitted when the maker or taker of a disputed swap escalates the swap to be resolved by CMTO token holders"),(0,l.kt)("h2",{id:"escalatedswapclosed"},"EscalatedSwapClosed"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"EscalatedSwapClosed(bytes16 swapID, uint256 makerPayout, uint256 takerPayout, uint256 confiscationPayout)\n")),(0,l.kt)("p",null,"Emitted when an escalated swap is closed"),(0,l.kt)("h2",{id:"servicefeeratechanged"},"ServiceFeeRateChanged"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"ServiceFeeRateChanged(uint256 newServiceFeeRate)\n")),(0,l.kt)("p",null,"Emitted when the service fee rate is changed"),(0,l.kt)("h2",{id:"minimumdisputeperiodchanged"},"MinimumDisputePeriodChanged"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"MinimumDisputePeriodChanged(uint256 newMinimumDisputePeriod)\n")),(0,l.kt)("p",null,"Emitted when the minimum dispute period is changed"),(0,l.kt)("h2",{id:"primarytimelockchanged"},"PrimaryTimelockChanged"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"PrimaryTimelockChanged(address oldPrimaryTimelock, address newPrimaryTimelock)\n")),(0,l.kt)("p",null,"Emitted when the Primary Timelock address is changed"),(0,l.kt)("h2",{id:"disputeresolutiontimelockchanged"},"DisputeResolutionTimelockChanged"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"DisputeResolutionTimelockChanged(address oldDisputeResolutionTimelock, address newDisputeResolutionTimelock)\n")),(0,l.kt)("p",null,"Emitted when the Dispute Resolution Timelock address is changed"),(0,l.kt)("h1",{id:"read-only-functions"},"Read-Only Functions"),(0,l.kt)("h2",{id:"get-service-fee-rate"},"Get Service Fee Rate"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getServiceFeeRate() view public returns (uint256)\n")),(0,l.kt)("p",null,"Returns the current service fee rate as a percentage times 100"),(0,l.kt)("h2",{id:"get-minimum-dispute-period"},"Get Minimum Dispute Period"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getMinimumDisputePeriod() view public returns (uint256)\n")),(0,l.kt)("p",null,"Returns the current minimum dispute period as a number of blocks"),(0,l.kt)("h2",{id:"get-supported-settlement-methods"},"Get Supported Settlement Methods"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getSupportedSettlementMethods() view public returns (bytes[] memory)\n")),(0,l.kt)("p",null,"Returns a list of byte arrays uniquely identifying each supported settlement method"),(0,l.kt)("h2",{id:"get-supported-stablecoins"},"Get Supported Stablecoins"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getSupportedStablecoins() view public returns (address[] memory)\n")),(0,l.kt)("p",null,"Returns a list containing the address of each supported stablecoin contract"),(0,l.kt)("h2",{id:"get-active-dispute-agents"},"Get Active Dispute Agents"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getActiveDisputeAgents() view public returns (address[] memory)\n")),(0,l.kt)("p",null,"Returns a list containing the addresses of each active dispute agent"),(0,l.kt)("h2",{id:"get-offer"},"Get Offer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getOffer(bytes16 offerID) view public returns (Offer memory)\n")),(0,l.kt)("p",null,"Returns an Offer struct with the specified id"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"offerID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the Offer to be returned")))),(0,l.kt)("h2",{id:"get-swap"},"Get Swap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getSwap(bytes16 swapID) view public returns (Swap memory)\n")),(0,l.kt)("p",null,"Returns a Swap struct with the specified id"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"swapID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the Swap to be returned")))),(0,l.kt)("h2",{id:"get-dispute"},"Get Dispute"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getDispute(bytes16 swapID) view public returns (Dispute memory)\n")),(0,l.kt)("p",null,"Returns a Dispute struct belonging to a disputed swap with the specified id"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"swapID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the swap corresponding to the Dispute to be returned")))),(0,l.kt)("h1",{id:"state-changing-functions"},"State-Changing Functions"),(0,l.kt)("h2",{id:"change-primary-timelock"},"Change Primary Timelock"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function changePrimaryTimelock(address newPrimaryTimelock) public\n")),(0,l.kt)("p",null,"Change the Primary Timelock address. This function can only be called by the current Primary Timelock."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"newPrimaryTimelock"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The address of the new Primary Timelock contract")))),(0,l.kt)("h2",{id:"change-dispute-resolution-timelock"},"Change Dispute Resolution Timelock"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function changeDisputeResolutionTimelock(address newDisputeResolutionTimelock) public\n")),(0,l.kt)("p",null,"Change the Dispute Resolution Timelock address. This function can only be called by the current Primary Timelock."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"newDisputeResolutionTimelock"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The address of the new Dispute Resolution Timelock contract")))),(0,l.kt)("h2",{id:"set-service-fee-rate"},"Set Service Fee Rate"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function setServiceFeeRate(uint256 newServiceFeeRate) public\n")),(0,l.kt)("p",null,"Set the current service fee rate, as a percentage times 100. This function can only be called by the current timelock."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"newServiceFeeRate"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The new service fee rate, expressed as a percentage times 100")))),(0,l.kt)("h2",{id:"set-minimum-dispute-period"},"Set Minimum Dispute Period"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function setMinimumDisputePeriod(uint256 newMinimumDisputePeriod) public\n")),(0,l.kt)("p",null,"Set the minimum dispute period, as a number of blocks. This function can only be called by the current timelock."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"newMinimumDisputePeriod"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The new minimum dispute period, as a number of blocks")))),(0,l.kt)("h2",{id:"set-settlement-method-support"},"Set Settlement Method Support"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function setSettlementMethodSupport(bytes calldata settlementMethod, bool support) public\n")),(0,l.kt)("p",null,"Adds or removes support for a specific settlement method. This function can only be called by the current timelock."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"settlementMethod"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The byte array uniquely identifying the settlement method in question")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"support"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Indicates whether support for the settlement method in question is to be added or removed")))),(0,l.kt)("h2",{id:"set-stablecoin-support"},"Set Stablecoin Support"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function setStablecoinSupport(address stablecoin, bool support) public\n")),(0,l.kt)("p",null,"Adds or removes support for a specific stablecoin. This function can only be called by the current timelock."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"stablecoin"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The address of the stablecoin contract in question")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"support"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Indicates whether support for the stablecoin in question is to be added or removed")))),(0,l.kt)("h2",{id:"set-dispute-agent-active"},"Set Dispute Agent Active"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function setDisputeAgentActive(address disputeAgentAddress, bool setActive) public\n")),(0,l.kt)("p",null,"Controls whether an address belongs to an active dispute agent. This function can only be called by the current timelock."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"disputeAgentAddress"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The address of the dispute agent for which active status will be set")))),(0,l.kt)("h2",{id:"open-offer"},"Open Offer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function openOffer(bytes16 offerID, Offer memory newOffer) public\n")),(0,l.kt)("p",null,"Opens a new offer to swap stablecoin for fiat."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"offerID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"A type-4 UUID that uniquely identifyies the new offer")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"newOffer"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Offer"),(0,l.kt)("td",{parentName:"tr",align:"left"},"An Offer struct containing the specifics of the new offer")))),(0,l.kt)("h2",{id:"edit-offer"},"Edit Offer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function editOffer(bytes16 offerID, Offer memory editedOffer) public\n")),(0,l.kt)("p",null,"Edits the supported settlement methods of an open swap offer. This function can only be called by the maker of the offer in question."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"offerID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the offer to be edited")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"editedOffer"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Offer"),(0,l.kt)("td",{parentName:"tr",align:"left"},"An Offer struct with the new settlement methods of the open offer")))),(0,l.kt)("h2",{id:"cancel-offer"},"Cancel Offer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function cancelOffer(bytes16 offerID) public\n")),(0,l.kt)("p",null,"Cancels an open offer. This function can only be called by the maker of the offer in question."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"offerID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the offer to be canceled")))),(0,l.kt)("h2",{id:"take-offer"},"Take Offer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function takeOffer(bytes16 offerID, Swap memory newSwap) public\n")),(0,l.kt)("p",null,"Takes an open swap offer."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"offerID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the offer to be taken")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"newSwap"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Swap"),(0,l.kt)("td",{parentName:"tr",align:"left"},"A Swap struct containing the specifics of the new swap")))),(0,l.kt)("h2",{id:"fill-swap"},"Fill Swap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function fillSwap(bytes16 swapID) public\n")),(0,l.kt)("p",null,"Fills a maker-as-seller swap by locking up takenSwapAmount of the maker's STBL, to be sent to the buyer upon swap closure. This function can only be called by the maker of a seller swap."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"swapID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the swap to be filled")))),(0,l.kt)("h2",{id:"report-payment-sent"},"Report Payment Sent"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function reportPaymentSent(bytes16 swapID) public\n")),(0,l.kt)("p",null,"Used by the buyer to indicate that they have sent payment. This function can only be called by the buyer."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"swapID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the swap for which payment has been sent")))),(0,l.kt)("h2",{id:"report-payment-received"},"Report Payment Received"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function reportPaymentReceived(bytes16 swapID) public\n")),(0,l.kt)("p",null,"Used by the seller to indicate that they have received payment. This function can only be called by the seller."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"swapID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the swap for which payment has been received")))),(0,l.kt)("h2",{id:"close-swap"},"Close Swap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function closeSwap(bytes16 swapID) public\n")),(0,l.kt)("p",null,"Used by the buyer to receive the stablecoin they just purchased and have their security deposit returned to them. Used by the seller to have their security deposit returned to them. This function can only be called by the buyer and seller."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"swapID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the swap to be closed")))),(0,l.kt)("h2",{id:"raise-dispute"},"Raise Dispute"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function raiseDispute(bytes16 swapID, address disputeAgent0, address disputeAgent1, address disputeAgent2) public\n")),(0,l.kt)("p",null,"Used by a swap maker or taker to raise a dispute for the swap. This function can only be called by the swap's maker or taker."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"swapID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the swap for which the dispute is being raised")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"disputeAgent0"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The address of the first dispute agent selected by the caller")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"disputeAgent1"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The address of the second dispute agent selected by the caller")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"disputeAgent2"),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The address of the third dispute agent selected by the caller")))),(0,l.kt)("h2",{id:"propose-resolution"},"Propose Resolution"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function proposeResolution(bytes16 swapID, uint256 makerPayout, uint256 takerPayout, uint256 confiscationPayout) public\n")),(0,l.kt)("p",null,"Used by a dispute agent to propose a resolution for a disputed swap. This function can only be called by a dispute agent assigned to the disputed swap."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"swapID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the disputed swap for which the resolution is being proposed")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"makerPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL that the caller recommends the maker be paid")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"takerPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL that the caller recommends the taker be paid")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"confiscationPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL that the caller recommends be confiscated and sent to the service fee pool")))),(0,l.kt)("h2",{id:"react-to-resolution-proposal"},"React To Resolution Proposal"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function reactToResolutionProposal(bytes16 swapID, DisputeReaction reaction) public\n")),(0,l.kt)("p",null,"Used by the maker and taker of a disputed swap to react to two or more matching resolution proposals. This function can only be called by the swap's maker or taker."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"swapID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the disputed swap for which the reaction is being submitted")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"reaction"),(0,l.kt)("td",{parentName:"tr",align:"left"},"DisputeReaction"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The caller's reaction to the two or more matching resolution proposals submitted by the selected dispute agents")))),(0,l.kt)("h2",{id:"close-disputed-swap"},"Close Disputed Swap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function closeDisputedSwap(bytes16 swapID) public\n")),(0,l.kt)("p",null,"Used by the maker and taker of a disputed swap with two or more identical resolution proposals accepted by the maker and taker to claim their STBL in the amounts specified in the accepted resolution proposals. This function can only be called by the swap's maker or taker."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"swapID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the swap to close")))),(0,l.kt)("h2",{id:"escalate-dispute"},"Escalate Dispute"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function escalateDispute(bytes16 swapID, EscalationReason reason) public\n")),(0,l.kt)("p",null,"Used by the maker or taker of a disputed swap to escalate the dispute for resolution by CMTO token holders. This function can only be called by the swap's maker or taker."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"swapID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the disputed swap to escalate")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"reason"),(0,l.kt)("td",{parentName:"tr",align:"left"},"EscalationReason"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The reason for escalating the disputed swap")))),(0,l.kt)("h2",{id:"close-escalated-swap"},"Close Escalated Swap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function closeEscalatedSwap(bytes16 swapID, uint256 makerPayout, uint256 takerPayout, uint256 confiscationPayout) public\n")),(0,l.kt)("p",null,"Used to close an escalated disputed swap. This function can only be called by the current timelock."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"swapID"),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes16"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The id of the escalated disputed swap to close")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"makerPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL the maker will receive")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"takerPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL the taker will receive")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"confiscationPayout"),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of STBL that will be confiscated and sent to the service fee pool")))))}k.isMDXComponent=!0},3905:function(e,t,a){a.d(t,{Zo:function(){return s},kt:function(){return k}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function d(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},s=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),u=p(a),k=r,c=u["".concat(o,".").concat(k)]||u[k]||m[k]||l;return a?n.createElement(c,i(i({ref:t},s),{},{components:a})):n.createElement(c,i({ref:t},s))}));function k(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=u;var d={};for(var o in t)hasOwnProperty.call(t,o)&&(d[o]=t[o]);d.originalType=e,d.mdxType="string"==typeof e?e:r,i[1]=d;for(var p=2;p<l;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);